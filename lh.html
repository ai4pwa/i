<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>HTML Loader</title>
</head>
<body>
  <div id="loader">Loading page...</div>

<script>
  // --- UTF-8 safe base64 decoder (unchanged) ---
  function fromBase64Unicode(b64) {
    const bin = atob(b64);
    const bytes = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
    try {
      return new TextDecoder('utf-8').decode(bytes);
    } catch (_) {
      return decodeURIComponent(escape(bin));
    }
  }

  const params = new URLSearchParams(window.location.search);
  const htmlFile = params.get('unique_id');

  if (!htmlFile) {
    document.getElementById("loader").innerText = "Error: No unique_id provided.";
  } else {
    const apiUrl =
      "https://app.base44.com/api/apps/6812ad73a9594a183279deba/entities/DataRecord" +
      "?user_id=user_jveo8b35q_1748241619184" +
      "&payload.unique_id=" +
      htmlFile;

    fetch(apiUrl, {
      headers: {
        api_key: "69315aa5aa7f4b6fa99c7a420da68bdd",
        "Content-Type": "application/json",
      },
    })
      .then(res => res.json())
      .then(async records => {
        if (!records.length) throw new Error("HTML file not found.");
        const base64Content = records[0].payload.file_content;
        const htmlCode = fromBase64Unicode(base64Content);

        const parser = new DOMParser();
        const doc = parser.parseFromString(htmlCode, "text/html");

        // --- set current document's dir/lang based on loaded doc ---
        if (doc.documentElement.lang) document.documentElement.lang = doc.documentElement.lang;
        const htmlDir = doc.documentElement.getAttribute('dir');
        const bodyDir = doc.body ? doc.body.getAttribute('dir') : null;
        if (htmlDir) document.documentElement.setAttribute('dir', htmlDir);
        else if (bodyDir) document.documentElement.setAttribute('dir', bodyDir);

        // Collect head children and separate scripts from non-scripts
        const headChildren = doc.head ? Array.from(doc.head.children) : [];
        const headNonScripts = headChildren.filter(n => n.tagName !== 'SCRIPT');
        const headScripts = headChildren.filter(n => n.tagName === 'SCRIPT');

        // Append non-script head nodes first (styles, link, meta, base, etc.)
        for (const node of headNonScripts) {
          try {
            // importNode preserves attributes/content and adapts it to current document
            const imported = document.importNode(node, true);
            document.head.appendChild(imported);
          } catch (e) {
            // If import fails for some node, try manual clone fallback
            document.head.appendChild(node.cloneNode(true));
          }
        }

        // Save body nodes (separate scripts)
        const bodyChildren = doc.body ? Array.from(doc.body.childNodes) : [];
        const bodyNonScripts = bodyChildren.filter(n => !(n.tagName === 'SCRIPT'));
        const bodyScripts = bodyChildren.filter(n => n.tagName === 'SCRIPT');

        // Safer css loaded detection: handle <style>, <link rel=stylesheet>, and cross-origin sheets
        function cssSeemsLoaded() {
          try {
            // If there are <style> tags in head, that's usually enough
            if (document.head.querySelectorAll('style').length > 0) return true;

            const links = Array.from(document.head.querySelectorAll('link[rel="stylesheet"]'));
            if (links.length === 0) {
              // no external stylesheet: ok
              return true;
            }

            // If we can inspect any stylesheet and see rules, assume loaded
            for (const sheet of document.styleSheets) {
              try {
                if (sheet.cssRules && sheet.cssRules.length > 0) return true;
              } catch (e) {
                // cross-origin stylesheets throw on cssRules — assume loaded
                return true;
              }
            }

            // if we found link tags but couldn't confirm rules yet, wait a bit
            return false;
          } catch (e) {
            return true;
          }
        }

        // Append body nodes (non-scripts) WITHOUT nuking the whole body.
        // Remove only the loader to preserve extension message channels / page lifecycle.
        const loaderEl = document.getElementById('loader');
        if (loaderEl) loaderEl.remove();

        for (const node of bodyNonScripts) {
          try {
            document.body.appendChild(document.importNode(node, true));
          } catch (e) {
            document.body.appendChild(node.cloneNode(true));
          }
        }

        // Utility: append scripts sequentially and preserve attributes (await external loads)
        async function appendScriptsSequentially(nodes, parent) {
          for (const node of nodes) {
            // Create a new script element and copy attributes
            const s = document.createElement('script');
            if (node.attributes) {
              for (let i = 0; i < node.attributes.length; i++) {
                const attr = node.attributes[i];
                // copy attribute exactly
                try { s.setAttribute(attr.name, attr.value); } catch (_) {}
              }
            }

            // If it's a module script, preserve module behavior (do NOT force async=false)
            const isModule = (node.getAttribute && node.getAttribute('type') === 'module');

            // Inline script
            if (!node.src) {
              s.textContent = node.textContent || '';
              parent.appendChild(s);
              // inline scripts execute immediately — wait next tick
              await new Promise(r => setTimeout(r, 0));
            } else {
              // External script: set src and wait for load (preserve attributes like crossorigin)
              s.src = node.src;
              // if not a module, force ordered execution by disabling async
              if (!isModule) s.async = false;
              // append then await load or error (resolve either way so chain continues)
              await new Promise(res => {
                s.onload = () => res();
                s.onerror = () => res();
                parent.appendChild(s);
              });
            }
          }
        }

        // Wait until CSS appears loaded or timeout, then append head scripts and body scripts sequentially.
        (async () => {
          const start = Date.now();
          while (!cssSeemsLoaded() && Date.now() - start < 5000) {
            await new Promise(r => setTimeout(r, 80));
          }
          // head scripts (in original order)
          await appendScriptsSequentially(headScripts, document.head);
          // body scripts (in original order)
          await appendScriptsSequentially(bodyScripts, document.body);
        })().catch(err => console.error('inject scripts error', err));
      })
      .catch(err => {
        document.getElementById("loader").innerText = `Error loading content: ${err}`;
        console.error(err);
      });
  }
</script>

</body>
</html>
